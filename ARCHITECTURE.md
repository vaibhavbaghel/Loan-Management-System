# Microservices Architecture - Deep Dive

## Table of Contents

1. [Overview](#overview)
2. [Service Decomposition](#service-decomposition)
3. [Communication Patterns](#communication-patterns)
4. [Data Architecture](#data-architecture)
5. [Deployment Topology](#deployment-topology)
6. [Scalability & Performance](#scalability--performance)
7. [Resilience & Fault Tolerance](#resilience--fault-tolerance)
8. [Migration Guide from Monolith](#migration-guide-from-monolith)

## Overview

This architecture decomposes the original monolithic Loan Management System into three independent microservices:

| Service | Purpose | Framework | Port | Database |
|---------|---------|-----------|------|----------|
| User Service | Auth, roles, approvals | Django 3.2 | 8001 | PostgreSQL |
| Loan Service | Loan lifecycle | Django 3.2 | 8002 | PostgreSQL |
| API Gateway | Request routing, auth | FastAPI | 8000 | None |

### Why Microservices?

**Original Monolith Problems:**
- Single Django app handles auth + business logic
- Shared database = tight coupling
- Scaling one feature scales the entire app
- Deployment changes affect all features
- Technology locked to Django

**Microservices Benefits:**
- Independent scaling per service
- Technology flexibility per service
- Separate deployments & CI/CD pipelines
- Isolated failure domains
- Team autonomy

## Service Decomposition

### User Service

**Responsibilities:**
- User registration (signup)
- Authentication (login, token generation)
- User profile management
- Role management (customer, agent, admin)
- Agent approval workflow

**Endpoints:**
```
POST   /api/user/signup                    → Create user
POST   /api/user/login                     → Authenticate
GET    /api/user/profile                   → Get my profile
POST   /api/user/create-admin              → Create admin (admin-only)
GET    /api/user/list-agents               → List customers
GET    /api/user/list-users                → List all users (admin-only)
GET    /api/user/list-approvals            → List pending approvals (admin-only)
PUT    /api/user/approve-delete/{user_id}  → Approve/reject agent
DELETE /api/user/approve-delete/{user_id}  → Delete agent
```

**Database Schema (Simplified):**
```
Users Table:
  - id
  - email (unique)
  - password (hashed)
  - first_name, last_name
  - is_customer, is_agent, is_admin (role flags)
  - is_approved (agent approval status)
  - created_at, updated_at
```

**Key Considerations:**
- Uses Django's AbstractUser for extensibility
- Stores role flags (not role_id) for flexibility
- JWT tokens generated by this service
- No knowledge of loans (decoupled)

### Loan Service

**Responsibilities:**
- Loan request creation (by agent for customer)
- Loan approval/rejection (by admin)
- Loan editing (by agent)
- Loan listing (filtered by role)
- EMI & interest calculations

**Endpoints:**
```
POST   /api/loan/customer-loan                  → Request loan (agent)
PUT    /api/loan/approve-reject-loan/{id}      → Approve/reject (admin)
PUT    /api/loan/edit-loan/{id}                → Edit loan (agent)
GET    /api/loan/list-loans-admin-agent        → List all loans
GET    /api/loan/list-loans-customer           → List my loans
```

**Database Schema (Simplified):**
```
Loans Table:
  - id
  - customer_id (FK to User Service, stored as string)
  - agent_id (FK to User Service, stored as string)
  - principal (loan amount)
  - interest (rate %)
  - months (tenure)
  - emi (monthly payment)
  - amount (total payable)
  - status (NEW, APPROVED, REJECTED)
  - start_date, end_date
  - created_at, modified_at
  
HistoricalRecords (via django-simple-history):
  - Tracks all changes to loans for audit
```

**Key Considerations:**
- Does NOT store User model; uses user IDs from JWT
- Implements state machine (NEW → APPROVED|REJECTED)
- Cannot edit APPROVED loans (business rule)
- Uses transactions + row locking on approve/reject (prevents races)
- Has DB indexes on frequently-filtered columns (status, customer_id)

### API Gateway

**Responsibilities:**
- Single entry point for all clients
- Route requests to appropriate service
- Forward JWT auth tokens
- Validate requests before proxying
- Rate limiting (TODO)
- Logging & monitoring (TODO)

**Request Flow:**
```
Client Request
     ↓
API Gateway validates auth header
     ↓
Routes to appropriate service (User/Loan)
     ↓
Service processes request
     ↓
API Gateway returns response to client
```

**Why FastAPI?**
- Async/await natively (handles concurrent requests efficiently)
- Lightweight (lower memory than Django)
- Modern type hints for validation
- Automatic OpenAPI/Swagger docs
- Fast startup time

## Communication Patterns

### Synchronous Communication (HTTP)

**API Gateway → Services:**
```
Client:
GET http://localhost:8000/api/user/profile
Authorization: Bearer eyJhbGc...

API Gateway:
GET http://user-service:8001/api/user/profile
Authorization: Bearer eyJhbGc...

User Service Response:
{
  "success": true,
  "data": { "email": "user@example.com", ... }
}

API Gateway Response:
{
  "success": true,
  "data": { "email": "user@example.com", ... }
}
```

**Service-to-Service (Loan → User):**
- Not implemented yet, but example:
  - Loan Service needs user details before creating loan
  - Loan Service calls User Service to validate customer exists
  - Calls internal User Service URL (within Docker network)

### Asynchronous Communication (Event Bus - Optional)

**Pattern: Publish-Subscribe via RabbitMQ**

```
User Service publishes:
  EventType: agent.approved
  Data: { user_id, email }

Loan Service subscribes to agent.approved:
  Updates agent approval limits
  Notifies dashboard

Loan Service publishes:
  EventType: loan.created
  Data: { loan_id, customer_id }

User Service subscribes to loan.created:
  Logs activity to user profile
  Sends email notification
```

**Benefits:**
- Loose coupling (services don't need to know each other)
- Eventual consistency (data syncs asynchronously)
- Resilience (if subscriber is down, publisher continues)
- Scalability (add new subscribers without changing publishers)

**Implementation in `services/shared/event_bus.py`:**
- `InMemoryEventBus` for development (events lost on restart)
- `RabbitMQEventBus` for production (durable, distributed)
- Switchable via `EVENT_BUS_TYPE` env var

## Data Architecture

### Database-Per-Service Pattern

```
┌─────────────────────────────────────────┐
│        Shared Infrastructure            │
│       (not shared between services)     │
│  User Service DB    │   Loan Service DB │
│  PostgreSQL         │   PostgreSQL      │
│  user_service_db    │   loan_service_db │
│  - Users table      │   - Loans table   │
│  - Roles            │   - History       │
└─────────────────────────────────────────┘
```

**Why Separate?**
- Independent scaling (Loan DB may be larger)
- Schema changes isolated (one team manages User schema)
- Backup/restore independent
- Technology flexibility (could use different DBs)

**Trade-offs:**
- Cannot use JOINs across services
- Need to denormalize data (copy user_id in Loan)
- Eventual consistency (data may be temporarily out of sync)
- Distributed transactions complex (two-phase commit risky)

### Denormalization Example

**Instead of:**
```sql
SELECT l.*, u.email FROM loans l
JOIN users u ON l.customer_id = u.id
```

**Do:**
```python
# Loan Service stores customer_id (string) from User Service
# Can optionally cache user details for performance
loan = Loan.objects.get(id=loan_id)
user_id = loan.customer_id
# Fetch user details from User Service via HTTP if needed
```

## Deployment Topology

### Local Development (Docker Compose)

```
Host Machine (localhost)
├── Container 1: API Gateway (FastAPI)
│   └── Port 8000
├── Container 2: User Service (Django)
│   └── Port 8001
├── Container 3: Loan Service (Django)
│   └── Port 8002
├── Container 4: PostgreSQL User DB
│   └── Port 5432
├── Container 5: PostgreSQL Loan DB
│   └── Port 5433
└── Optional: RabbitMQ
    └── Port 5672, 15672 (management UI)

All containers on: microservices_network (Docker bridge network)
```

### Production (Kubernetes)

```
K8s Cluster
├── Namespace: microservices
├── Deployment: api-gateway
│   ├── Replicas: 3
│   ├── Service (LoadBalancer): api-gateway:8000
│   └── Image: myregistry/api-gateway:1.0.0
├── Deployment: user-service
│   ├── Replicas: 2
│   ├── Service (ClusterIP): user-service:8001
│   └── Image: myregistry/user-service:1.0.0
├── Deployment: loan-service
│   ├── Replicas: 2
│   ├── Service (ClusterIP): loan-service:8002
│   └── Image: myregistry/loan-service:1.0.0
├── StatefulSet: postgres-user
│   ├── Volume: 100Gi
│   └── Service: postgres-user:5432
├── StatefulSet: postgres-loan
│   ├── Volume: 100Gi
│   └── Service: postgres-loan:5432
├── ConfigMap: service-config (environment vars)
├── Secret: db-credentials
├── Secret: jwt-secrets
└── Ingress: api.example.com → api-gateway:8000
```

## Scalability & Performance

### Horizontal Scaling

**Scale API Gateway:**
```
# Docker
docker-compose up -d --scale api-gateway=3

# Kubernetes
kubectl scale deployment api-gateway --replicas=5
```
Use load balancer (HAProxy, NGINX, K8s Ingress) to distribute traffic.

**Scale User Service:**
```
# Increase replicas if auth throughput is bottleneck
docker-compose up -d --scale user-service=3

# DB: Increase connection pool, use read replicas for profile queries
```

**Scale Loan Service:**
```
# Increase replicas for loan processing
docker-compose up -d --scale loan-service=4

# DB: Add indexes, use partitioning for large tables
```

### Performance Optimizations

1. **Caching (Redis):**
   - Cache frequently-accessed users (24h TTL)
   - Cache loan listings with pagination
   - Reduces DB load

2. **Database Indexing:**
   ```python
   # In Loan model:
   class Meta:
       indexes = [
           models.Index(fields=['status']),           # for filtering
           models.Index(fields=['customer_id']),      # for listing
           models.Index(fields=['created_at']),       # for sorting
       ]
   ```

3. **Connection Pooling:**
   ```python
   # Use pgBouncer between services and PostgreSQL
   # Reuses connections, reduces overhead
   ```

4. **Async Processing (Celery):**
   ```python
   # Long-running tasks (email, PDF generation) run async
   @celery.task
   def send_loan_approval_email(loan_id):
       ...
   ```

5. **API Pagination:**
   ```
   GET /api/loan/list-loans-admin-agent?page=1&page_size=20
   ```

## Resilience & Fault Tolerance

### Circuit Breaker Pattern

**Problem:** If Loan Service is down, API Gateway keeps making requests, wasting resources.

**Solution:** Circuit Breaker
```
Closed (normal):        Request flows normally
                        ↓
Failure threshold reached
                        ↓
Open (circuit broken):  Requests fail immediately without calling service
                        ↓
After timeout (30s)
                        ↓
Half-Open:              Try one request
                        ↓
If success → Closed
If failure → Open
```

**Implementation:**
```python
from pybreaker import CircuitBreaker

breaker = CircuitBreaker(
    fail_max=5,           # Fail 5 times before opening
    reset_timeout=60      # Try again after 60s
)

async def call_user_service():
    return breaker.call(user_service.request, ...)
```

### Retry Strategy

```python
# Retry transient failures (timeouts, 503)
# Don't retry client errors (400, 404, 401)

def should_retry(exception):
    return isinstance(exception, (TimeoutError, ServiceUnavailable))

for attempt in range(3):  # Max 3 retries
    try:
        return await service.request(...)
    except Exception as e:
        if not should_retry(e) or attempt == 2:
            raise
        await asyncio.sleep(2 ** attempt)  # Exponential backoff
```

### Health Checks

```
User Service:     GET /health → 200 OK
Loan Service:     GET /health → 200 OK
API Gateway:      GET /health → 200 OK
postgres-user:    pg_isready -U postgres
postgres-loan:    pg_isready -U postgres
```

Docker compose uses these to restart failed containers.

### Monitoring & Alerting (TODO)

```
Prometheus:
  - Scrapes /metrics from each service
  - Tracks: requests/sec, latency, errors, CPU, memory

Grafana:
  - Visualizes metrics
  - Dashboards: service health, traffic, errors

Alerting:
  - Alert if request latency > 500ms
  - Alert if error rate > 5%
  - Alert if service down for > 60s
```

## Migration Guide from Monolith

### Step 1: Refactor Monolith into Modules (Week 1)

In the original `backend/` folder:
- Keep user app isolated (minimal imports from loan app)
- Keep loan app isolated (imports from user for validation only)
- No circular dependencies

### Step 2: Extract User Service (Week 2)

1. Copy `backend/user/` → `services/user-service/user/`
2. Create standalone Django project structure
3. Copy database, migrations
4. Deploy side-by-side with monolith (both running)
5. A/B test: some requests to old, some to new service

### Step 3: Extract Loan Service (Week 3)

1. Copy `backend/loan/` → `services/loan-service/loan/`
2. Update to use user_id instead of User FK
3. Create standalone Django project structure
4. Deploy side-by-side

### Step 4: Create API Gateway (Week 4)

1. Build FastAPI gateway routing to both services
2. Implement authentication forwarding
3. Test all endpoints
4. Deploy with monolith still running

### Step 5: Gradual Migration (Week 5-6)

```
Week 5:
  - 10% traffic → microservices
  - 90% traffic → monolith
  - Monitor errors, latency

Week 6:
  - 50% traffic → microservices
  - 50% traffic → monolith

Week 7:
  - 100% traffic → microservices
  - Decommission monolith
```

### Step 6: Cleanup

- Remove old `backend/` monolith code
- Delete duplicate code
- Update CI/CD pipelines

## Key Metrics to Monitor During Migration

- Request latency (p50, p95, p99)
- Error rate by endpoint
- Service availability
- Database query performance
- API Gateway throughput

---

**Next: See [README.md](README.md) for quickstart guide.**
